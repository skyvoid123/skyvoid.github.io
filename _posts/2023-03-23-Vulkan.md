---
layout: post
title: Vulkan概述
category: Graphics-API
---

**原创内容，转载请注明**

---

## RenderPipelineState

{% highlight C++ %}
struct VkGraphicsPipelineCreateInfo {
    int32_t                                          stageCount;
    const VkPipelineShaderStageCreateInfo* {
        VkShaderStageFlagBits               stage;  // VK_SHADER_STAGE_VERTEX_BIT、VK_SHADER_STAGE_FRAGMENT_BIT
        VkShaderModule                      module;  // vkCreateShaderModule(device, &shaderModuleCreateInfo, nullptr, &module)，
                                                     //     VkShaderModuleCreateInfo {
                                                     //     size_t             codeSize;  // 注意是字节大小
                                                     //     const uint32_t*    pCode;     // 注意是uint32_t*
                                                     // } shaderModuleCreateInfo;
        const char*                         pName;  // shader主函数名
        const VkSpecializationInfo* {  // 见"Shader Function Specialization"章节
            uint32_t            mapEntryCount;
            const VkSpecializationMapEntry* {
                uint32_t    constantID;
                uint32_t    offset;
                size_t      size;            
            }                   pMapEntries;
            size_t              dataSize;
            const void*         pData;        
        }                                   pSpecializationInfo;
    }                                                pStages;
    const VkPipelineVertexInputStateCreateInfo*      pVertexInputState;
    const VkPipelineInputAssemblyStateCreateInfo*    pInputAssemblyState;  // .topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST; .primitiveRestartEnable = VK_FALSE;
    const VkPipelineTessellationStateCreateInfo*     pTessellationState;
    const VkPipelineViewportStateCreateInfo*         pViewportState;  // {uint32_t viewportCount; const VkViewport* pViewports; uint32_t scissorCount; const VkRect2D* pScissors}
    const VkPipelineRasterizationStateCreateInfo* {
        VkBool32                depthClampEnable;  // = VK_FALSE;
        VkBool32                rasterizerDiscardEnable;  // = VK_FALSE;
        VkPolygonMode           polygonMode;  //  = VK_POLYGON_MODE_FILL、VK_POLYGON_MODE_LINE...;
        VkCullModeFlags         cullMode;  // = VK_CULL_MODE_BACK_BIT;
        VkFrontFace             frontFace;  // VK_FRONT_FACE_COUNTER_CLOCKWISE;
        VkBool32                depthBiasEnable;  // = VK_FALSE;
        float                   depthBiasConstantFactor;
        float                   depthBiasClamp;
        float                   depthBiasSlopeFactor;
        float                   lineWidth;  // = 1.0;
    }                                                pRasterizationState;
    const VkPipelineMultisampleStateCreateInfo*      pMultisampleState;  // {VkSampleCountFlagBits rasterizationSamples; VkBool32 alphaToCoverageEnable; VkBool32 alphaToOneEnable; VkBool32 sampleShadingEnable}
    const VkPipelineDepthStencilStateCreateInfo*     pDepthStencilState;
    const VkPipelineColorBlendStateCreateInfo*       pColorBlendState;
    const VkPipelineDynamicStateCreateInfo* {
        uint32_t                           dynamicStateCount;
        const VkDynamicState*              pDynamicStates;  // VK_DYNAMIC_STATE_VIEWPORT/VK_DYNAMIC_STATE_SCISSOR/VK_DYNAMIC_STATE_STENCIL_REFERENCE/VK_DYNAMIC_STATE_CULL_MODE_EXT等
    }                                                pDynamicState;  // 需在录制指令时调用对应的vkCmdSetXxx进行动态设置
    VkPipelineLayout {
        uint32_t                      setLayoutCount;
        const VkDescriptorSetLayout*  pSetLayouts;  // 对应shader中"layout(set = 0, binding = 0) uniform UniformBufferObject0 { ... }
                                                    //             layout(set = 1, binding = 0) uniform UniformBufferObject1 { ... }"
        uint32_t                      pushConstantRangeCount;
        const VkPushConstantRange*    pPushConstantRanges;  // 针对少量的uniform数据，可以通过vkCmdPushConstants将其直接存在CommandBuffers内
    }                                                layout;  // 同metal的ArgumentBuffer的uniform参数布局声明
    VkRenderPass                                     renderPass;
    uint32_t                                         subpass;  // 指定使用的是上面renderPass中哪个subpass(索引值)
    VkPipeline                                       basePipelineHandle;  // 以现有的pipeline创建此pipeline，当flags为VK_PIPELINE_CREATE_DERIVATIVE_BIT时才生效
    int32_t                                          basePipelineIndex;  // 指定用这个索引代表的pipeline来生成新的pipeline，当flags为VK_PIPELINE_CREATE_DERIVATIVE_BIT时才生效
} pipelineCreateInfo;

VkPipeline graphicsPipeline;
vkCreateGraphicsPipelines(device, pipelineCache /*or VK_NULL_HANDLE*/, 1, &pipelineInfo, nullptr, &graphicsPipeline);
...
vkDestroyPipeline(device, graphicsPipeline, nullptr);
{% endhighlight %}

**PipelineCache**

{% highlight C++ %}
struct VkPipelineCacheCreateInfo {
    VkPipelineCacheCreateFlags    flags;
    size_t                        initialDataSize;  // pInitialData字节数。若为0，则初始化一个空的pipeline cache
    const void*                   pInitialData;  // pipeline cache data。如果与device不兼容，则初始化一个空的pipeline cache
} pipelineCacheCreateInfo;

VkPipelineCache pipelineCache;  // 线程安全的：传入vkCreateGraphicsPipelines、vkCreateComputePipelines，指令内部进行同步，保证复用和更新是线程安全的
vkCreatePipelineCache(device, &pipelineCacheCreateInfo, nullptr, &pipelineCache);
vkDestroyPipelineCache(device, pipelineCache, nullptr);

// 提取pipeline cache data
size_t dataSize;
vkGetPipelineCacheData(device, pipelineCache, &dataSize, nullptr);
std::vector<uint8_t>pipelineCacheData(dataSize);
vkGetPipelineCacheData(device, pipelineCache, &dataSize, pipelineCacheData.data()));
// 将pipelineCacheData写入文件保存下来，供下次vkCreatePipelineCache时读取至pipelineCacheCreateInfo.pInitialData中
{% endhighlight %}

### VertexInputState

{% highlight C++ %}
struct VkPipelineVertexInputStateCreateInfo {
    uint32_t vertexBindingDescriptionCount;
    const VkVertexInputBindingDescription* {
        uint32_t             binding;  // 对应metal的bufferIndex，对应CPU端的一个VkBuffer(vkCmdBindVertexBuffers关联VkBuffer与binging值的映射)
        uint32_t             stride;
        VkVertexInputRate    inputRate;     
    } pVertexBindingDescriptions;
        
    uint32_t vertexAttributeDescriptionCount;
    const VkVertexInputAttributeDescription* {
        uint32_t    location;  // 对应shader中"layout(location = n) in inXxx;"的"n"值
        uint32_t    binding;  // 同上VkVertexInputBindingDescription::binding
        VkFormat    format;
        uint32_t    offset;    
    } pVertexAttributeDescriptions;
} vertexInputState;
{% endhighlight %}

### DepthStencilState

{% highlight C++ %}
struct VkPipelineDepthStencilStateCreateInfo {
    VkBool32                                  depthTestEnable;
    VkBool32                                  depthWriteEnable;
    VkCompareOp                               depthCompareOp;
    VkBool32                                  depthBoundsTestEnable;
    VkBool32                                  stencilTestEnable;
    VkStencilOpState {
        VkStencilOp    failOp;
        VkStencilOp    passOp;
        VkStencilOp    depthFailOp;
        VkCompareOp    compareOp;
        uint32_t       compareMask;
        uint32_t       writeMask;
        uint32_t       reference;  // metal是在renderEncoder阶段设置的(metal更灵活)，如[renderEncoder setStencilReferenceValue:128];
                                   // 设置为VK_DYNAMIC_STATE_STENCIL_REFERENCE后，亦可vkCmdSetStencilReference
    }                                         front;
    VkStencilOpState                          back;
    float                                     minDepthBounds;
    float                                     maxDepthBounds;
} depthStencilState;
{% endhighlight %}

### DescriptorSetLayout

{% highlight C++ %}
struct VkDescriptorSetLayoutCreateInfo {
    uint32_t                               bindingCount;
    const VkDescriptorSetLayoutBinding* {
        uint32_t              binding;  // 对应shader中的"layout(binding = x) uniform xxType xxVar;"，所有ShaderStage阶段共用同一份
        VkDescriptorType      descriptorType;  // VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER、VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER、VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT等
        uint32_t              descriptorCount;  // 若>1表示uniform数组
        VkShaderStageFlags    stageFlags;  // VK_SHADER_STAGE_VERTEX_BIT、VK_SHADER_STAGE_FRAGMENT_BIT，指定哪些ShaderStage阶段可以使用此binding资源
        const VkSampler*      pImmutableSamplers;  // 当descriptorType为VK_DESCRIPTOR_TYPE_SAMPLER或VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER时，此字段可用descriptorCount个immutable samplers初始化，一种优化
    }                                      pBindings;
} descriptorSetLayoutCreateInfo;

VkDescriptorSetLayout descriptorSetLayout;
vkCreateDescriptorSetLayout(device, &descriptorSetLayoutCreateInfo, nullptr, &descriptorSetLayout);
...
vkDestroyDescriptorSetLayout(device, descriptorSetLayout, nullptr);
{% endhighlight %}

### RenderPassState

![img](/assets/vulkan-renderpass.png)
[Introduction to Vulkan Render Passes](https://developer.samsung.com/galaxy-gamedev/resources/articles/renderpasses.html)

{% highlight C++ %}
// VkRenderPass描述Attachments的布局
// metal的RenderPipeline配置时只需配置colorAttachmentDescriptor(format+blend相关)、depthAttachmentPixelFormat、stencilAttachmentPixelFormat
struct VkRenderPassCreateInfo {
    uint32_t                              attachmentCount;
    const VkAttachmentDescription* {
        VkFormat                  format;
        VkSampleCountFlagBits     samples;  // 启用MSAA时的采样数，其他情况均为VK_SAMPLE_COUNT_1_BIT；metal只需在创建msaaTexture时设置MTLTextureDescriptor.sampleCount即可
        VkAttachmentLoadOp        loadOp;  // metal是在渲染阶段，创建renderEncoder时，配置在MTLRenderPassDescriptor内。metal更灵活
        VkAttachmentStoreOp       storeOp;  // 同上
        VkAttachmentLoadOp        stencilLoadOp;  // 同上
        VkAttachmentStoreOp       stencilStoreOp;  // 同上
        VkImageLayout             initialLayout;
        VkImageLayout             finalLayout;
    }                                     pAttachments;
    uint32_t                              subpassCount;
    const VkSubpassDescription*           pSubpasses;  // 指出subpass使用了哪些VkAttachmentReference，包括InputAttachments、ColorAttachments、DepthStencilAttachment、ResolveAttachments、PreserveAttachments(此subpass未使用，但需要保留给后续subpass使用)
    uint32_t                              dependencyCount;
    const VkSubpassDependency* {
        uint32_t                srcSubpass;  // pSubpasses数组中的索引值，第一个subpas之前的srcSubpass为VK_SUBPASS_EXTERNAL
        uint32_t                dstSubpass;  // 同上
        VkPipelineStageFlags    srcStageMask;  // VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT等，同metal的updateFence:afterStages:
        VkPipelineStageFlags    dstStageMask;  // VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT等，同metal的waitForFence:beforeStages:
        VkAccessFlags           srcAccessMask;  // VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT等
        VkAccessFlags           dstAccessMask;  // VK_ACCESS_SHADER_READ_BIT等
        VkDependencyFlags       dependencyFlags;  // VK_DEPENDENCY_BY_REGION_BIT(Only need the current fragment (or tile) synchronized, not the whole framebuffer)等
    }                                     pDependencies;  // 描述subpasses之间的依赖关系
} renderPassCreateInfo;

VkRenderPass renderPass;
vkCreateRenderPass(device, &renderPassCreateInfo, nullptr, &renderPass);
...
vkDestroyRenderPass(device, renderPass, nullptr);
{% endhighlight %}

## Record Command Buffers

{% highlight C++ %}
void createCommandPool() {
    QueueFamilyIndices queueFamilyIndices = findQueueFamilies(physicalDevice);

    VkCommandPoolCreateInfo poolInfo{};
    poolInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
    poolInfo.queueFamilyIndex = queueFamilyIndices.graphicsFamily.value();

    if (vkCreateCommandPool(device, &poolInfo, nullptr, &commandPool) != VK_SUCCESS) {
        throw std::runtime_error("failed to create graphics command pool!");
    }
}
VkCommandBuffer beginSingleTimeCommands() {
    VkCommandBufferAllocateInfo allocInfo{};
    allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
    allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
    allocInfo.commandPool = commandPool;
    allocInfo.commandBufferCount = 1;

    VkCommandBuffer commandBuffer;
    vkAllocateCommandBuffers(device, &allocInfo, &commandBuffer);

    VkCommandBufferBeginInfo beginInfo{};
    beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
    beginInfo.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;  // 一次性的，同metal的MTLCommandBuffer

    vkBeginCommandBuffer(commandBuffer, &beginInfo);  // vkBeginCommandBuffer会隐式重置commandBuffer

    return commandBuffer;
}

void endSingleTimeCommands(VkCommandBuffer commandBuffer) {
    vkEndCommandBuffer(commandBuffer);

    VkSubmitInfo submitInfo{};
    submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
    submitInfo.commandBufferCount = 1;
    submitInfo.pCommandBuffers = &commandBuffer;

    vkQueueSubmit(graphicsQueue, 1, &submitInfo, VK_NULL_HANDLE);
    vkQueueWaitIdle(graphicsQueue);

    vkFreeCommandBuffers(device, commandPool, 1, &commandBuffer);
}

void createCommandBuffers() {
    commandBuffers.resize(swapChainFramebuffers.size());

    VkCommandBufferAllocateInfo allocInfo{};
    allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
    allocInfo.commandPool = commandPool;
    allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
    allocInfo.commandBufferCount = (uint32_t) commandBuffers.size();

    if (vkAllocateCommandBuffers(device, &allocInfo, commandBuffers.data()) != VK_SUCCESS) {
        throw std::runtime_error("failed to allocate command buffers!");
    }

    for (size_t i = 0; i < commandBuffers.size(); i++) {
        VkCommandBufferBeginInfo beginInfo{};
        beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
        beginInfo.flags = 0；  // 可重复使用，非一次性的，同metal的IndirectCommandBuffer
        
        if (vkBeginCommandBuffer(commandBuffers[i], &beginInfo) != VK_SUCCESS) {
            throw std::runtime_error("failed to begin recording command buffer!");
        }

        VkRenderPassBeginInfo renderPassInfo{};
        renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
        renderPassInfo.renderPass = renderPass;
        renderPassInfo.framebuffer = swapChainFramebuffers[i];
        renderPassInfo.renderArea.offset = {0, 0};
        renderPassInfo.renderArea.extent = swapChainExtent;

        std::array<VkClearValue, 2> clearValues{};
        clearValues[0].color = {{0.0f, 0.0f, 0.0f, 1.0f}};
        clearValues[1].depthStencil = {1.0f, 0};

        renderPassInfo.clearValueCount = static_cast<uint32_t>(clearValues.size());
        renderPassInfo.pClearValues = clearValues.data();

        vkCmdBeginRenderPass(commandBuffers[i], &renderPassInfo, VK_SUBPASS_CONTENTS_INLINE);

            vkCmdBindPipeline(commandBuffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, graphicsPipeline);

            VkBuffer vertexBuffers[] = {vertexBuffer};
            VkDeviceSize offsets[] = {0};
            vkCmdBindVertexBuffers(commandBuffers[i], 0, 1, vertexBuffers, offsets);

            vkCmdBindIndexBuffer(commandBuffers[i], indexBuffer, 0, VK_INDEX_TYPE_UINT32);

            vkCmdBindDescriptorSets(commandBuffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, pipelineLayout, 0, 1, &descriptorSets[i], 0, nullptr);

            vkCmdDrawIndexed(commandBuffers[i], static_cast<uint32_t>(indices.size()), 1, 0, 0, 0);

        vkCmdEndRenderPass(commandBuffers[i]);

        if (vkEndCommandBuffer(commandBuffers[i]) != VK_SUCCESS) {
            throw std::runtime_error("failed to record command buffer!");
        }
    }
}

// 每帧更新UniformBuffer
void updateUniformBuffer(uint32_t currentImage) {
    static auto startTime = std::chrono::high_resolution_clock::now();

    auto currentTime = std::chrono::high_resolution_clock::now();
    float time = std::chrono::duration<float, std::chrono::seconds::period>(currentTime - startTime).count();

    UniformBufferObject ubo{};
    ubo.model = glm::rotate(glm::mat4(1.0f), time * glm::radians(90.0f), glm::vec3(0.0f, 0.0f, 1.0f));
    ubo.view = glm::lookAt(glm::vec3(2.0f, 2.0f, 2.0f), glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3(0.0f, 0.0f, 1.0f));
    ubo.proj = glm::perspective(glm::radians(45.0f), swapChainExtent.width / (float) swapChainExtent.height, 0.1f, 10.0f);
    ubo.proj[1][1] *= -1;

    // 直接更新uniformBuffers的内存数据，这样不用重新绑定
    void* data;
    vkMapMemory(device, uniformBuffersMemory[currentImage], 0, sizeof(ubo), 0, &data);
        memcpy(data, &ubo, sizeof(ubo));
    vkUnmapMemory(device, uniformBuffersMemory[currentImage]);
}

void drawFrame() {
    // 渲染前的准备阶段
    vkWaitForFences(device, 1, &inFlightFences[currentFrame], VK_TRUE, UINT64_MAX);

    uint32_t imageIndex;
    VkResult result = vkAcquireNextImageKHR(device, swapChain, UINT64_MAX, imageAvailableSemaphores[currentFrame], VK_NULL_HANDLE, &imageIndex);

    if (result == VK_ERROR_OUT_OF_DATE_KHR) {
        recreateSwapChain();
        return;
    } else if (result != VK_SUCCESS && result != VK_SUBOPTIMAL_KHR) {
        throw std::runtime_error("failed to acquire swap chain image!");
    }

    // 渲染数据更新阶段
    updateUniformBuffer(imageIndex);
    
    // 渲染指令录制阶段
    // 每帧渲染指令不变，因此此阶段为空。若渲染指令有变化，则需重新录制，详情见下面代码
    
    // 渲染指令提交阶段
    if (imagesInFlight[imageIndex] != VK_NULL_HANDLE) {
        vkWaitForFences(device, 1, &imagesInFlight[imageIndex], VK_TRUE, UINT64_MAX);
    }
    imagesInFlight[imageIndex] = inFlightFences[currentFrame];

    VkSubmitInfo submitInfo{};
    submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;

    VkSemaphore waitSemaphores[] = {imageAvailableSemaphores[currentFrame]};
    VkPipelineStageFlags waitStages[] = {VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT};
    submitInfo.waitSemaphoreCount = 1;
    submitInfo.pWaitSemaphores = waitSemaphores;
    submitInfo.pWaitDstStageMask = waitStages;

    submitInfo.commandBufferCount = 1;
    submitInfo.pCommandBuffers = &commandBuffers[imageIndex];

    VkSemaphore signalSemaphores[] = {renderFinishedSemaphores[currentFrame]};
    submitInfo.signalSemaphoreCount = 1;
    submitInfo.pSignalSemaphores = signalSemaphores;

    vkResetFences(device, 1, &inFlightFences[currentFrame]);

    if (vkQueueSubmit(graphicsQueue, 1, &submitInfo, inFlightFences[currentFrame]) != VK_SUCCESS) {
        throw std::runtime_error("failed to submit draw command buffer!");
    }

    // 渲染上屏阶段
    VkPresentInfoKHR presentInfo{};
    presentInfo.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;

    presentInfo.waitSemaphoreCount = 1;
    presentInfo.pWaitSemaphores = signalSemaphores;

    VkSwapchainKHR swapChains[] = {swapChain};
    presentInfo.swapchainCount = 1;
    presentInfo.pSwapchains = swapChains;

    presentInfo.pImageIndices = &imageIndex;

    result = vkQueuePresentKHR(presentQueue, &presentInfo);

    if (result == VK_ERROR_OUT_OF_DATE_KHR || result == VK_SUBOPTIMAL_KHR || framebufferResized) {
        framebufferResized = false;
        recreateSwapChain();
    } else if (result != VK_SUCCESS) {
        throw std::runtime_error("failed to present swap chain image!");
    }

    currentFrame = (currentFrame + 1) % MAX_FRAMES_IN_FLIGHT;
}

// 渲染指令录制阶段
void recordCommands(VkCommandBuffer commandBuffer) {
    // 重置并激活commandBuffer
    VkCommandBufferBeginInfo commandBufferBeginInfo{};
    commandBufferBeginInfo.sType = VK_STRUCT_TYPE_COMMAND_BUFFER_BEGIN_INFO;
    commandBufferBeginInfo.flags = 0;
    commandBufferBeginInfo.pInheritanceInfo = nullptr;
    vkBeginCommandBuffer(commandBuffer, &commandBufferBeginInfo);

    // 渲染一个RenderPass
    {
        std::array<VkImageView, 2> attachments = {colorImageView0, depthImageView0};
        VkFramebufferCreateInfo framebufferCreateInfo{};
        framebufferCreateInfo.sType = VK_STRUCT_TYPE_FRAMEBUFFER_CREATE_INFO;
        framebufferCreateInfo.renderPass = renderpass;  // 缓存VkRenderPasses，避免冗余创建
        framebufferCreateInfo.attachmentCount = static_cast<uint32_t>(attachments.size());
        framebufferCreateInfo.pAttachments = attachments.data();
        framebufferCreateInfo.width = attachmentWidth;
        framebufferCreateInfo.height = attachmentHeight;
        framebufferCreateInfo.layers = 1;
        VkFramebuffer framebuffer;
        vkCreateFramebuffer(device, &framebufferCreateInfo, nullptr, &framebuffer);
        fencedDeleter.deleteWhenUnused(framebuffer);

        std::array<VkClearValue, 2> clearValues{};
        clearValues[0].color = {{0.0f, 0.0f, 0.0f, 1.0f}};
        clearValues[1].depthStencil = {1.0f, 0};
        VkRenderPassBeginInfo renderPassBeginInfo{};
        renderPassBeginInfo.sType = VK_STRUCT_TYPE_RENDER_PASS_BEGIN_INFO;
        renderPassBeginInfo.renderPass = renderpass;
        renderPassBeginInfo.framebuffer = framebuffer0;
        renderPassBeginInfo.renderArea.offset = {0, 0};
        renderPassBeginInfo.renderArea.extent = VkExtent2D(attachmentWidth, attachmentHeight);
        renderPassBeginInfo.clearValueCount = static_cast<uint32_t>(clearValues.size);
        renderPassBeginInfo.pClearValues = clearValues.data();
        vkCmdBeginRenderPass(commandBuffer, &renderPassBeginInfo, VK_SUBPASS_CONTENTS_INLINE /*VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS*/);
        
        // 一个DrawCall
        {
            vkCmdBindPipeline(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, graphicsPipeline);

            VkBuffer vertexBuffers[] = {vertexBuffer};
            VkDeviceSize offsets[] = {0};
            vkCmdBindVertexBuffers(commandBuffer, 0 /*firstBinding*/, 1 /*bindingCount*/, vertexBuffers, offsets);
            
            vkCmdBindIndexBuffer(commandBuffer, indexBuffer, 0, VK_INDEX_TYPE_UINT32);

            vkCmdBindDescriptorSets(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, pipelineLayout, 0 /*firstSet*/, 1 /*descriptorSetCount*/, &descriptorSet, 0 /*dynamicOffsetCount*/, nullptr);
            
            // 对应pipelineLayoutCreateInfo.pPushConstantRanges = &VkPushConstantRange{VK_SHADER_STAGE_VERTEX_BIT, 0/*offset*/, sizeof(mvp)}; 不知道offset字段含义
            // 对应shader："layout (std140, push_constant) uniform PushConsts { mat4 mvp; } pushConsts;"
            vkCmdPushConstants(commandBuffer, pipelineLayout, VK_SHADER_STAGE_VERTEX_BIT, 0/*offset*/, sizeof(mvp), &mvp);  // glm::mat4 mvp = ...;
            
            // 设置DynamicState，对应管线状态graphicsPipeline.pDynamicState
            VkViewport viewport{0, 0, attachmentWidth, attachmentHeight, 0, 1};
            vkCmdSetViewport(commandBuffer, 0 /*firstViewport*/, 1 /*viewportCount*/, &viewport);

            vkCmdDrawIndexed(commandBuffer, static_cast<uint32_t>(indices.size()), 1, 0, 0, 0);
        }
        // 另一个DrawCall
        {
            ...
            vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance);
        }

        vkCmdEndRenderPass(commandBuffer);
    }

    // 渲染另一个RenderPass
    {
        std::array<VkImageView, 2> attachments = {colorImageView1, depthImageView1};
        ...
    }

    vkEndCommandBuffer(commandBuffer);
}

// 更新Uniform
void updateDescriptorSets() {
    VkDescriptorBufferInfo bufferInfo{};
    bufferInfo.buffer = uniformBuffer;
    bufferInfo.offset = 0;
    bufferInfo.range = sizeof(UniformBufferObject);
    
    VkDescriptorImageInfo imageInfo{};
    imageInfo.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    imageInfo.imageView = srcImageView;
    imageInfo.sampler = linearSampler;
    
    std::array<VkWriteDescriptorSet, 2> descriptorWrites{};
    
    descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[0].dstSet = descriptorSet;
    descriptorWrites[0].dstBinding = 0;
    descriptorWrites[0].dstArrayElement = 0;
    descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    descriptorWrites[0].descriptorCount = 1;
    descriptorWrites[0].pBufferInfo = &bufferInfo;
    
    descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
    descriptorWrites[1].dstSet = descriptorSet;
    descriptorWrites[1].dstBinding = 1;
    descriptorWrites[1].dstArrayElement = 0;
    descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
    descriptorWrites[1].descriptorCount = 1;
    descriptorWrites[1].pBufferInfo = &imageInfo;
    
    vkUpdateDescriptorSets(device, static_cast<uint32_t>(descriptorWrites.size()), descriptorWrites.data(), 0 /*descriptorCopyCount*/, nullptr);
}
{% endhighlight %}

### Encoding a Single Rendering Pass Using Multiple Threads
secondary command buffer，同metal的MTLParallelRenderCommandEncoder

**primary command buffer与secondary command buffer，以及secondary command buffers之间均不继承任何状态：**
- When a command buffer begins recording, all state in that command buffer is undefined.
- When secondary command buffer(s) are recorded to execute on a primary command buffer, the secondary command buffer inherits no state from the primary command buffer.
- All state of the primary command buffer is undefined after an execute secondary command buffer command is recorded.
- Exception: if the primary command buffer is inside a render pass instance, then the render pass and subpass state is not disturbed by executing secondary command buffers.

**primary command buffer与secondary command buffers生命周期关系：**
- if the primary is submitted to a queue, both the primary and any secondaries recorded to it move to the pending state.
- Once execution of the primary completes, so it does for any secondary recorded within it.
- After all executions of each command buffer complete, they each move to their appropriate completion state (either to the executable state or the invalid state, as specified below).
- If a secondary moves to the invalid state or the initial state, then all primary buffers it is recorded in move to the invalid state. A primary moving to any other state does not affect the state of a secondary recorded in it.
- Resetting or freeing a primary command buffer removes the lifecycle linkage to all secondary command buffers that were recorded into it.

**Command buffer生命周期图：** <br>
Resetting occurs as a result of vkResetCommandBuffer or vkResetCommandPool, or as part of vkBeginCommandBuffer (which additionally puts the command buffer in the recording state).
![img](/assets/vulkan-commandbuffer.png)

{% highlight C++ %}
// 渲染主线程初始化阶段
struct ThreadData {
    VkCommandPool commandPool;
    VkCommandBuffer secondaryCommandBuffer;
    PushConstantBlock pushConstBlock;
};
std::vector<ThreadData> threadDataList(kThreadNum);
for (const auto& threadData : threadDataList) {
    VkCommandPoolCreateInfo cmdPoolInfo{};
    cmdPoolInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
    cmdPoolInfo.queueFamilyIndex = queueFamilyIndex;
    cmdPoolInfo.flags = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;  // If VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT is not set, vkResetCommandBuffer must not be called for any command buffer allocated from that pool.
    vkCreateCommandPool(device, &cmdPoolInfo, nullptr, &threadData.commandPool);
    
    VkCommandBufferAllocateInfo allocInfo{};
    allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
    allocInfo.commandPool = threadData.commandPool;
    allocInfo.level = VK_COMMAND_BUFFER_LEVEL_SECONDARY;
    allocInfo.commandBufferCount = 1;
    vkAllocateCommandBuffers(device, &allocInfo, &threadData.secondaryCommandBuffer);
}

// 渲染主线程每帧渲染阶段
vkBeginCommandBuffer(primaryCommandBuffer, &primaryCmdBufInfo);
// The primary command buffer does not contain any rendering commands
// These are stored (and retrieved) from the secondary command buffers
vkCmdBeginRenderPass(primaryCommandBuffer, &renderPassBeginInfo, VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS);
VkCommandBufferInheritanceInfo inheritanceInfo{};  // 仅供secondary command buffer使用
inheritanceInfo.renderPass = renderPass;
// subpass is the index of the subpass within the render pass instance that the VkCommandBuffer will be executed within.
inheritanceInfo.subpass = 0;
// framebuffer can refer to the VkFramebuffer object that the VkCommandBuffer will be rendering to if it is executed within a render pass instance. It can be VK_NULL_HANDLE if the framebuffer is not known. 此时若可指定则性能更优
// Secondary command buffer also use the currently active framebuffer
inheritanceInfo.framebuffer = framebuffer;

// 各自线程录制各自的threadData[i].secondaryCommandBuffer
// 子线程0如下：
VkCommandBufferBeginInfo secondaryCmdBufInfo{};
commandBufferBeginInfo.flags = VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT;  // 表示此secondary command buffer在一个render pass范围内
commandBufferBeginInfo.pInheritanceInfo = &inheritanceInfo;
VkCommandBuffer secondaryCmdBuffer = threadData[0].secondaryCommandBuffer;
vkBeginCommandBuffer(secondaryCmdBuffer, &secondaryCmdBufInfo);
    vkCmdSetViewport(tsecondaryCmdBuffer, 0, 1, &viewport);
    vkCmdSetScissor(secondaryCmdBuffer, 0, 1, &scissor);
    vkCmdBindPipeline(secondaryCmdBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, graphicPipeline);
    vkCmdPushConstants(secondaryCmdBuffer, pipelineLayout, VK_SHADER_STAGE_VERTEX_BIT, 0, sizeof(PushConstantBlock), &threadData[0].pushConstBlock);
    vkCmdBindVertexBuffers(secondaryCmdBuffer, 0, 1, &vertexBuffer, &offset);
    vkCmdBindIndexBuffer(secondaryCmdBuffer, indexBuffer, 0, VK_INDEX_TYPE_UINT32);
    vkCmdDrawIndexed(secondaryCmdBuffer, indexCount, 1, 0, 0, 0);
vkEndCommandBuffer(secondaryCmdBuffer);

// 子线程1...
// 子线程2...
// ...
// 同步等待所有子线程执行完成
threadPool.wait();

// Contains the list of secondary command buffers to be submitted
std::vector<VkCommandBuffer> secondaryCommandBuffers;
for (const auto& threadData : threadDataList) {
    secondaryCommandBuffers.push_back(threadData.secondaryCommandBuffer);
}

// Execute render commands from the secondary command buffer
vkCmdExecuteCommands(primaryCommandBuffer, secondaryCommandBuffers.size(), secondaryCommandBuffers.data());

vkCmdEndRenderPass(primaryCommandBuffer);

vkEndCommandBuffer(primaryCommandBuffer);
{% endhighlight %}

## Resource Objects: Buffers and Images
vulkan的buffer和image资源均需要手动进行内存管理，以及资源依赖跟踪（hazard tracking）
![img](/assets/vulkan-resource_memory.png)

{% highlight C++ %}
// VkBuffer
struct VkBufferCreateInfo {
    VkDeviceSize           size;
    VkBufferUsageFlags     usage;  // VK_BUFFER_USAGE_TRANSFER_SRC_BIT、VK_BUFFER_USAGE_VERTEX_BUFFER_BIT、VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT
    VkSharingMode          sharingMode;  // VK_SHARING_MODE_EXCLUSIVE、VK_SHARING_MODE_CONCURRENT
    uint32_t               queueFamilyIndexCount;
    const uint32_t*        pQueueFamilyIndices;  // 指定共享此buffer的queues。如果sharingMode不是VK_SHARING_MODE_CONCURRENT，则忽略此字段
} bufferCreateInfo;

VkBuffer buffer;
vkCreateBuffer(device, &bufferCreateInfo, nullptr, &buffer);

VkMemoryRequirements memRequirements;
vkGetBufferMemoryRequirements(device, buffer, &memRequirements);

VkMemoryAllocateInfo allocInfo{};
allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
allocInfo.allocationSize = memRequirements.size;
allocInfo.memoryTypeIndex = findMemoryType(memRequirements.memoryTypeBits, properties);  // properties = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT
VkDeviceMemory bufferMemory;
vkAllocateMemory(device, &allocInfo, nullptr, &bufferMemory);

vkBindBufferMemory(device, buffer, bufferMemory, 0 /*memoryOffset*/);
...
vkDestroyBuffer(device, buffer, nullptr);
vkFreeMemory(device, bufferMemory, nullptr);

uint32_t findMemoryType(uint32_t typeFilter, VkMemoryPropertyFlags properties) {
    VkPhysicalDeviceMemoryProperties memProperties;
    vkGetPhysicalDeviceMemoryProperties(physicalDevice, &memProperties);
    for (uint32_t i = 0; i < memProperties.memoryTypeCount; i++) {
        if ((typeFilter & (1 << i)) && (memProperties.memoryTypes[i].propertyFlags & properties) == properties) {
            return i;
        }
    }
    throw std::runtime_error("failed to find suitable memory type!");
}
{% endhighlight %}

{% highlight C++ %}
// VkImage
truct VkImageCreateInfo {
    VkImageType              imageType;  // VK_IMAGE_TYPE_1D、VK_IMAGE_TYPE_2D、VK_IMAGE_TYPE_3D
    VkFormat                 format;  // VK_FORMAT_R8G8B8A8_UNORM等
    VkExtent3D               extent;  // {width, height, depth}
    uint32_t                 mipLevels;
    uint32_t                 arrayLayers;
    VkSampleCountFlagBits    samples;  // msaa
    VkImageTiling            tiling;  // VK_IMAGE_TILING_OPTIMAL、VK_IMAGE_TILING_LINEAR
    VkImageUsageFlags        usage;  // VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT、VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT、VK_IMAGE_USAGE_SAMPLED_BIT
    VkSharingMode            sharingMode;  // VK_SHARING_MODE_EXCLUSIVE、VK_SHARING_MODE_CONCURRENT
    uint32_t                 queueFamilyIndexCount;
    const uint32_t*          pQueueFamilyIndices;  // 指定共享此buffer的queues。如果sharingMode不是VK_SHARING_MODE_CONCURRENT，则忽略此字段
    VkImageLayout            initialLayout;  // VK_IMAGE_LAYOUT_UNDEFINED、VK_IMAGE_LAYOUT_GENERAL、VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL
} imageCreateInfo;

struct VkImageViewCreateInfo {
    VkImage                    image;
    VkImageViewType            viewType;  // VK_IMAGE_VIEW_TYPE_2D、VK_IMAGE_VIEW_TYPE_CUBE、VK_IMAGE_VIEW_TYPE_2D_ARRAY
    VkFormat                   format;
    VkComponentMapping {
        VkComponentSwizzle  r;  // = VK_COMPONENT_SWIZZLE_R、VK_COMPONENT_SWIZZLE_ZERO、VK_COMPONENT_SWIZZLE_ONE等
        VkComponentSwizzle  g;  // VK_COMPONENT_SWIZZLE_G
        VkComponentSwizzle  b;  // specifying the component value placed in the B component of the output vector
        VkComponentSwizzle  a;
    }                          components;
    VkImageSubresourceRange {
        VkImageAspectFlags  aspectMask;  // VK_IMAGE_ASPECT_COLOR_BIT、VK_IMAGE_ASPECT_DEPTH_BIT、VK_IMAGE_ASPECT_STENCIL_BIT
        uint32_t            baseMipLevel;
        uint32_t            levelCount;
        uint32_t            baseArrayLayer;
        uint32_t            layerCount;            
    }                          subresourceRange;
} imagViewCreateInfo;

VkImage image;
vkCreateImage(device, &imageCreateInfo, nullptr, &image);
// allocate imageMemory，同上面的bufferMemory
vkBindImageMemory(device, image, imageMemory, 0);

VkImageView imageView;
vkCreateImageView(device, &imagViewCreateInfo, nullptr, &imageView)
...
vkDestroyImageView(device, imageView, nullptr);
vkDestroyImage(device, image, nullptr);
vkFreeMemory(device, imageMemory, nullptr);
{% endhighlight %}

{% highlight C++ %}
enum VkMemoryPropertyFlagBits {
    VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT = 0x00000001,       // video memory，仅供GPU使用，不能mapping
    VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT = 0x00000002,       // system memory，可供CPU使用，可mapping；GPU访问很慢。uncached：writes may be write-combined
    VK_MEMORY_PROPERTY_HOST_COHERENT_BIT = 0x00000004,      // 不需要调用CPU缓存管理指令(vkFlushMappedMemoryRanges/vkInvalidateMappedMemoryRanges)，CPU或GPU写另一端均可见
    VK_MEMORY_PROPERTY_HOST_CACHED_BIT = 0x00000008,        // system memory，CPU缓存，加速CPU访问
    VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = 0x00000010,   // video memory，与VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT互斥，与VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT一起使用可创建memoryless image(TBR架构)
  // Provided by VK_VERSION_1_1
    VK_MEMORY_PROPERTY_PROTECTED_BIT = 0x00000020,
  // Provided by VK_AMD_device_coherent_memory
    VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD = 0x00000040,
  // Provided by VK_AMD_device_coherent_memory
    VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD = 0x00000080,
  // Provided by VK_NV_external_memory_rdma
    VK_MEMORY_PROPERTY_RDMA_CAPABLE_BIT_NV = 0x00000100,
}
{% endhighlight %}

**AMD Radeon RX “Vega”显卡内存结构，其中Type2是特例**
![img](/assets/vulkan-memory_type.png)

{% highlight C++ %}
// CPU访问GPU内存(Host Access to Device Memory Objects)
// Memory objects created with vkAllocateMemory are not directly host accessible.
// Memory objects created with the memory property VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT are considered mappable.
// Memory objects must be mappable in order to be successfully mapped on the host.
// While a range of device memory is host mapped, the application is responsible for synchronizing both device and host access to that memory range.
VkResult vkMapMemory(
    VkDevice                                    device,
    VkDeviceMemory                              memory,
    VkDeviceSize                                offset,
    VkDeviceSize                                size,
    VkMemoryMapFlags                            flags,
    void**                                      ppData);

// 将CPU数据写至VkDeviceMemory中
void* pData = nullptr;
//stagingBufferMemory已指定VK_MEMORY_PROPERTY_HOST_COHERENT_BIT
vkMapMemory(device, stagingBufferMemory, 0, imageSize, 0, &pData);
    memcpy(pData, pPixels, static_cast<size_t>(imageSize));
vkUnmapMemory(device, stagingBufferMemory);  // To unmap a memory object once host access to it is no longer needed by the application

// stagingBufferMemory未指定VK_MEMORY_PROPERTY_HOST_COHERENT_BIT
vkMapMemory(device, stagingBufferMemory, 0, imageSize, 0, &pData);
    memcpy(pData, pPixels, static_cast<size_t>(imageSize));
    
    struct VkMappedMemoryRange {
    VkDeviceMemory     memory;
    VkDeviceSize       offset;
    VkDeviceSize       size;
    } mappedMemoryRange;
    // 写完mapped memory(pData)之后，必须调用vkFlushMappedMemoryRanges，确保mapped memory刷新到VkDeviceMemory中
    // To flush ranges of non-coherent memory from the host caches
    vkFlushMappedMemoryRanges(device, 1 /*memoryRangeCount*/, &mappedMemoryRange);
    
vkUnmapMemory(device, stagingBufferMemory);

// VkDeviceMemory数据读至CPU data中
void* pData = nullptr;
//stagingBufferMemory已指定VK_MEMORY_PROPERTY_HOST_COHERENT_BIT
vkMapMemory(device, stagingBufferMemory, 0, imageSize, 0, &pData);
// 使用读取出的pData数据
vkUnmapMemory(device, stagingBufferMemory);

// stagingBufferMemory未指定VK_MEMORY_PROPERTY_HOST_COHERENT_BIT
vkMapMemory(device, stagingBufferMemory, 0, imageSize, 0, &pData);
// 使用pData数据之前，必须调用vkInvalidateMappedMemoryRanges，确保VkDeviceMemory刷新到mapped memory中
// To invalidate ranges of non-coherent memory from the host caches.
// Mapping non-coherent memory does not implicitly invalidate that memory.
vkInvalidateMappedMemoryRanges(device, 1 /*memoryRangeCount*/, &mappedMemoryRange);
// CPU端使用读取出的pData数据
vkUnmapMemory(device, stagingBufferMemory);
{% endhighlight %}

### DescriptorSet

{% highlight C++ %}
// DescriptorPool，与DescriptorSetLayout对应，DescriptorSetLayout确定了其VkDescriptorPoolSize(几个buffer、几个texture、几个sampler，以及各自的binding值)
// 每一个DescriptorSetLayout实例(缓存去冗余)创建一个DescriptorPool，并一次性生成多个对应的DescriptorSets缓存下来
struct VkDescriptorPoolCreateInfo {
    uint32_t                       maxSets;  // 此pool可创建descriptorSet的最大数量
    uint32_t                       poolSizeCount;
    const VkDescriptorPoolSize* {
        VkDescriptorType  type;  // VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER、VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER
        uint32_t          descriptorCount;  // 该decriptorPool可创建此类型descriptor的总数量，= descriptorCountInSetLayout[type] * maxSets;
    }                              pPoolSizes;
} descriptorPoolCreateInfo;
// VK_DESCRIPTOR_TYPE_STORAGE_BUFFER 可读、可写、可原子操作(VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER 只读)
// VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC等dynamic buffer，其offset的计算为VkDescriptorBufferInfo.offset + the dynamic offset of vkCmdBindDescriptorSets

VkDescriptorPool descriptorPool;
vkCreateDescriptorPool(device, &descriptorPoolCreateInfo, nullptr, &decriptorPool);

// DescriptorSet
struct VkDescriptorSetAllocateInfo {
    VkDescriptorPool                descriptorPool;
    uint32_t                        descriptorSetCount;
    const VkDescriptorSetLayout*    pSetLayouts;  // descriptorSetCount个元素的数组
} descriptorSetAllocInfo;

std::vector<VkDescriptorSet> descriptorSets(n);
vkAllocateDescriptorSets(device, &descriptorSetAllocInfo, descriptorSets.data());
...
vkFreeDescriptorSets(device, descriptorPool, n/*descriptorSetCount*/, descriptorSets.data());
vkDestroyDescriptorPool(device, descriptorPool, nullptr);  // 清楚descriptorPool中的所有descriptorSets，无需调用vkFreeDescriptorSets
{% endhighlight %}

### Resource Synchronization
**Execution and Memory Dependencies**
- An execution dependency is a guarantee that for two sets of operations, the first set must happen-before the second set. If an operation happens-before another operation, then the first operation must complete before the second operation is initiated. But, execution dependencies alone are not sufficient to guarantee that values resulting from writes in one set of operations can be read from another set of operations.
- A memory dependency is an execution dependency which includes availability and visibility operations such that:
The first set of operations happens-before the availability operation.
The availability operation happens-before the visibility operation.    （availability operation：cache写入main memory，main memory内容正确）
The visibility operation happens-before the second set of operations.    （visibility operation：    main memory刷新cache，cache内容正确）

> Execution and memory dependencies are used to solve data hazards, i.e. to ensure that read and write operations occur in a well-defined order. Write-after-read hazards can be solved with just an execution dependency, but read-after-write and write-after-write hazards need appropriate memory dependencies to be included between them. If an application does not include dependencies to solve these hazards, the results and execution orders of memory accesses are undefined.<br>
To increase performance under the hood, Vulkan uses a series of caching mechanisms between the fast L1/L2 cache memory on the CPU and GPU cores and the relatively slow main RAM memory.<br>
When one core writes to memory (to a render target, for example), the updates could still only exist in a cache and not be available or visible to another core ready to work with it. Memory barriers are the tools we can use to ensure that caches are flushed and our memory writes from commands executed before the barrier are available to the pending after-barrier commands. They are also the tool we can use to invalidate caches so that the latest data is visible to the cores that will execute after-barrier commands.<br>
详情可见vulkan官方博客[《Understanding Vulkan Synchronization》](https://www.khronos.org/blog/understanding-vulkan-synchronization)

**下面的同步原语均保证了内存依赖（memory dependency），[官方示例](https://github.com/KhronosGroup/Vulkan-Docs/wiki/Synchronization-Examples)**

### Fence
VkFence，CPU与GPU直接的同步。<br>
等价于metal的dispatch_semaphore_t信号量+addCompletedHandler:

{% highlight C++ %}
VkResult vkQueueSubmit(
    VkQueue                queue,
    uint32_t               submitCount,
    const VkSubmitInfo*    pSubmits,
    VkFence                fence  // queue执行完成后，fence被置为signaled
);

// return code: VK_SUCCESS表示fence是signaled，VK_NOT_READY表示是unsigned，VK_ERROR_DEVICE_LOST表示device丢失
VkResult vkGetFenceStatus(device, fence);
VkResult vkWaitForFences(device, 1 /*fenceCount*/, &fence, VK_TRUE /*waitAll*/, UINT64_MAX);
{% endhighlight %}

### Semaphore
VkSemaphore，不同queues之间的同步，或同一个queue内部submissions之间的粗粒度同步。隐式保证了memory dependency

{% highlight C++ %}
// graphicsQueue与presentQueue之间的同步
std::vector<VkSemaphore> imageAvailableSemaphores;
std::vector<VkSemaphore> renderFinishedSemaphores;

// 每帧渲染阶段
// 获取可上屏的image，当取到后会将imageAvailableSemaphores[currentFrame]置为signaled状态
vkAcquireNextImageKHR(device, swapChain, UINT64_MAX, imageAvailableSemaphores[currentFrame], VK_NULL_HANDLE /*fence*/, &imageIndex);
...
// 提交queue
{
    VkSubmitInfo submitInfo{};
    submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
    
    // COLOR_ATTACHMENT_OUTPUT阶段需要等待上屏image
    VkSemaphore waitSemaphores[] = {imageAvailableSemaphores[currentFrame]};
    VkPipelineStageFlags waitStages[] = {VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT};
    submitInfo.waitSemaphoreCount = 1;
    submitInfo.pWaitSemaphores = waitSemaphores;
    submitInfo.pWaitDstStageMask = waitStages;  // 只有waitSemaphore才可以指定具体等待阶段
    
    submitInfo.commandBufferCount = 1;
    submitInfo.pCommandBuffers = &commandBuffer;
    
    // queue执行完成后，发送signalSemaphores通知
    VkSemaphore signalSemaphores[] = {renderFinishedSemaphores[currentFrame]};
    submitInfo.signalSemaphoreCount = 1;
    submitInfo.pSignalSemaphores = signalSemaphores;
    
    vkQueueSubmit(graphicsQueue, 1, &submitInfo, inFlightFences[currentFrame]);
}

// 上屏
{
    VkPresentInfoKHR presentInfo{};
    presentInfo.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;
    
    presentInfo.waitSemaphoreCount = 1;
    presentInfo.pWaitSemaphores = signalSemaphores;  // 等待queue执行完成
    
    VkSwapchainKHR swapChains[] = {swapChain};
    presentInfo.swapchainCount = 1;
    presentInfo.pSwapchains = swapChains;
    
    presentInfo.pImageIndices = &imageIndex;
    
    vkQueuePresentKHR(presentQueue, &presentInfo);
}
{% endhighlight %}

### Barrier
VkMemoryBarrier/VkBufferMemoryBarrier/VkImageMemoryBarrier，同一个queue内部不同commandBuffers之间，或同一个commandBuffer内部的同步。<br>
等价于metal的MTLFence

{% highlight C++ %}
struct VkImageMemoryBarrier {
    VkAccessFlags                  srcAccessMask;  // VK_ACCESS_SHADER_READ_BIT、VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT
    VkAccessFlags                  dstAccessMask;  // VK_ACCESS_TRANSFER_READ_BIT、VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT
    VkImageLayout                  oldLayout;  // VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL、VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL
    VkImageLayout                  newLayout;  // VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL、VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL
    uint32_t                       srcQueueFamilyIndex;  // 转移image所有权时才使用，否则置为VK_QUEUE_FAMILY_IGNORED
    uint32_t                       dstQueueFamilyIndex;  // 同上
    VkImage                        image;
    VkImageSubresourceRange {
        VkImageAspectFlags  aspectMask;  // VK_IMAGE_ASPECT_COLOR_BIT、VK_IMAGE_ASPECT_DEPTH_BIT、VK_IMAGE_ASPECT_STENCIL_BIT
        uint32_t            baseMipLevel;
        uint32_t            levelCount;
        uint32_t            baseArrayLayer;
        uint32_t            layerCount;            
    }                              subresourceRange;
} imageBarrier;

struct VkBufferMemoryBarrier {
    VkAccessFlags      srcAccessMask;
    VkAccessFlags      dstAccessMask;
    uint32_t           srcQueueFamilyIndex;
    uint32_t           dstQueueFamilyIndex;
    VkBuffer           buffer;
    VkDeviceSize       offset;
    VkDeviceSize       size;
} bufferBarrier;

struct VkMemoryBarrier {
    VkAccessFlags      srcAccessMask;
    VkAccessFlags      dstAccessMask;
} memoryBarrier;

void vkCmdPipelineBarrier(
    VkCommandBuffer               commandBuffer,
    VkPipelineStageFlags          srcStageMask,
    VkPipelineStageFlags          dstStageMask,  // 等待srcStageMask阶段执行完成后，才可开始执行dstStageMask
    VkDependencyFlags             dependencyFlags,  // 通常为0
    uint32_t                      memoryBarrierCount,
    const VkMemoryBarrier*        pMemoryBarriers,  // 针对所有的内存进行同步，包括buffer、image，通常不会使用此barrier，粒度过大
    uint32_t                      bufferMemoryBarrierCount,
    const VkBufferMemoryBarrier*  pBufferMemoryBarriers,  // 针对特定buffer的同步
    uint32_t                      imageMemoryBarrierCount,
    const VkImageMemoryBarrier*   pImageMemoryBarriers    /// 针对特定image的同步
);  // 若pMemoryBarriers、pBufferMemoryBarriers、pImageMemoryBarriers均不设置，则此barrier是一个execution barrier
{% endhighlight %}

### Event
VkEvent，同一个queue内部不同commandBuffers之间，或同一个commandBuffer内部的同步，也可是CPU与GPU的command之间的同步。<br>
CPU和GPU均可以将VkEvent置为signaled状态，但只有GPU能够等待VkEvent，CPU只能够查询VkEvent的当前状态（signaled or unsignaled）
<br>等价于metal的MTLEvent、MTLSharedEvent

{% highlight C++ %}
VkResult vkCreateEvent(
    VkDevice                                    device,
    const VkEventCreateInfo*                    pCreateInfo,  // 其中的VkEventCreateFlags::VK_EVENT_CREATE_DEVICE_ONLY_BIT表示CPU端不使用此VkEvent
    const VkAllocationCallbacks*                pAllocator,
    VkEvent*                                    pEvent);
    
VkResult vkGetEventStatus(VkDevice device, VkEvent event);  // CPU端查询VkEvent状态：VK_EVENT_SET表示signaled，VK_EVENT_RESET表示unsignaled
VkResult vkSetEvent(VkDevice device, VkEvent event);  // CPU端设置VkEvent为signaled状态
VkResult vkResetEvent(VkDevice device, VkEvent event);  // CPU端设置VkEvent为unsignaled状态

// vkCmdSetEvent behaves identically to vkCmdSetEvent2(VK_VERSION_1_3), except that it does not define an access scope.
// The extra information provided by vkCmdSetEvent2 compared to vkCmdSetEvent allows implementations to more efficiently schedule
// the operations required to satisfy the requested dependencies. 
// With vkCmdSetEvent, the full dependency information is not known until vkCmdWaitEvents is recorded, 
// forcing implementations to insert the required operations at that point and not before.
void vkCmdSetEvent(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask);  // GPU端设置VkEvent为signaled状态
void vkCmdResetEvent(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask);  // GPU端设置VkEvent为unsignaled状态

void vkCmdWaitEvents(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    eventCount,
    const VkEvent*                              pEvents,
    VkPipelineStageFlags                        srcStageMask,
    VkPipelineStageFlags                        dstStageMask,
    uint32_t                                    memoryBarrierCount,
    const VkMemoryBarrier*                      pMemoryBarriers,
    uint32_t                                    bufferMemoryBarrierCount,
    const VkBufferMemoryBarrier*                pBufferMemoryBarriers,
    uint32_t                                    imageMemoryBarrierCount,
    const VkImageMemoryBarrier*                 pImageMemoryBarriers
); // 若pMemoryBarriers、pBufferMemoryBarriers、pImageMemoryBarriers均不设置，则此wait是一个execution barrier，同vkCmdPipelineBarrier
{% endhighlight %}

![img](/assets/vulkan-event.png)

> If a command buffer is waiting for an event to be signaled from the host, the application must signal the event before submitting the command buffer, as described in the queue forward progress section.<br>
vkCmdWaitEvents2 is used with vkCmdSetEvent2 to define a memory dependency between two sets of action commands, roughly in the same way as pipeline barriers, but split into two commands such that work between the two may execute unhindered(无受阻碍).<br>
Applications should be careful to avoid race conditions when using events. There is no direct ordering guarantee between vkCmdWaitEvents2  and vkCmdResetEvent2, vkCmdResetEvent, or vkCmdSetEvent. Another execution dependency (e.g. a pipeline barrier or semaphore with VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT) is needed to prevent such a race condition.

## Shader
### Shader Function Specialization

{% highlight C++ %}
// in shader
layout (constant_id = 0) const bool offset_defined;
layout (constant_id = 1) const bool color_defined;
layout (constant_id = 3) const bool hasInputTexture;
{% endhighlight %}

{% highlight C++ %}
// in cpu
struct SpecializationData {
    bool offset_defined;
    bool color_defined;
    bool hasInputTexture
} specializationData;

std::array<VkSpecializationMapEntry, 3> specializationMapEntries{};
specializationMapEntries[0].constantID = 0;
specializationMapEntries[0].size = sizeof(specializationData.offset_defined);
specializationMapEntries[0].offset = offsetof(SpecializationData, offset_defined);;

specializationMapEntries[1].constantID = 1;
specializationMapEntries[1].size = sizeof(specializationData.color_defined);
specializationMapEntries[1].offset = offsetof(SpecializationData, color_defined);

specializationMapEntries[2].constantID = 3;
specializationMapEntries[2].size = sizeof(specializationData.hasInputTexture);
specializationMapEntries[2].offset = offsetof(SpecializationData, hasInputTexture);

VkSpecializationInfo specializationInfo{};
specializationInfo.dataSize = sizeof(specializationData);
specializationInfo.mapEntryCount = static_cast<uint32_t>(specializationMapEntries.size());
specializationInfo.pMapEntries = specializationMapEntries.data();
specializationInfo.pData = &specializationData;

std::array<VkPipelineShaderStageCreateInfo, 2> shaderStages{};
shaderStages[0].stage = VK_SHADER_STAGE_VERTEX_BIT;
shaderStages[0].module = vertShaderModule;
shaderStages[0].pName = "main";
shaderStages[0].pSpecializationInfo = &specializationInfo;
...
pipelineCreateInfo.stageCount = 2;
pipelineCreateInfo.pStages = shaderStages;
{% endhighlight %}
